<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>蛋仔派对：实验室嘉年华</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f1f5ff;
        --panel: rgba(255, 255, 255, 0.9);
        --accent: #5b6dff;
        --accent-dark: #3040f0;
        --egg: #ffe8b2;
        --egg-outline: #f9c875;
        --rival: #ffc0cb;
        --star: #ffd740;
        --text: #1f2356;
        --muted: #6c7395;
        --success: #2ecc71;
        --danger: #ff4d6d;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Nunito", "PingFang SC", "Microsoft YaHei", system-ui,
          sans-serif;
        background: linear-gradient(135deg, #e0e7ff, #fdf2ff);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 24px 16px 48px;
      }

      .wrapper {
        width: min(1100px, 100%);
        display: grid;
        gap: 20px;
      }

      .back-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
        padding: 8px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        box-shadow: 0 8px 22px rgba(91, 109, 255, 0.18);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .back-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(91, 109, 255, 0.24);
      }

      .panel {
        background: var(--panel);
        border-radius: 28px;
        padding: 24px 28px;
        box-shadow: 0 18px 40px rgba(45, 55, 130, 0.18);
        display: grid;
        gap: 18px;
      }

      h1 {
        margin: 0;
        font-size: clamp(28px, 6vw, 40px);
        font-weight: 800;
        letter-spacing: 1px;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: clamp(16px, 4vw, 18px);
        line-height: 1.6;
        max-width: 720px;
      }

      .canvas-wrapper {
        position: relative;
        width: 100%;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 18px 42px rgba(26, 33, 72, 0.22);
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: radial-gradient(circle at 20% 20%, #fff7e6, #dceaff 80%);
      }

      .hud {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: center;
      }

      .hud-item {
        min-width: 140px;
        padding: 10px 18px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6),
          0 10px 18px rgba(45, 55, 130, 0.1);
        font-size: 14px;
        text-align: center;
        font-variant-numeric: tabular-nums;
      }

      .hud-item strong {
        display: block;
        margin-top: 4px;
        font-size: 20px;
        color: var(--accent-dark);
      }

      .controls {
        display: grid;
        gap: 12px;
        font-size: 14px;
        color: var(--muted);
      }

      .notice {
        padding: 12px 16px;
        border-radius: 16px;
        background: rgba(91, 109, 255, 0.12);
        color: var(--accent-dark);
        font-size: 14px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }

      .controls ul {
        list-style: none;
        display: grid;
        gap: 8px;
        padding: 0;
        margin: 0;
      }

      .controls li {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .key {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 10px;
        border-radius: 10px;
        border: 1px solid rgba(91, 109, 255, 0.3);
        background: rgba(91, 109, 255, 0.05);
        font-weight: 600;
        color: var(--accent);
      }

      .toast {
        position: fixed;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(33, 45, 110, 0.88);
        color: #fff;
        padding: 12px 20px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(33, 45, 110, 0.35);
        font-size: 14px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      @media (max-width: 768px) {
        .panel {
          padding: 20px 22px;
        }

        .hud-item {
          min-width: 120px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <a class="back-button" href="../index.html">
        <span>←</span>
        更多游戏
      </a>
      <div class="panel">
        <h1>蛋仔派对：实验室嘉年华</h1>
        <p class="subtitle">
          控制圆滚滚的实验室蛋仔，在流体跑道上收集 FigureYa 图稿、使用冲刺撞开对手，抢夺更多珍贵数据，成为派对冠军！
        </p>
        <div class="hud" role="status" aria-live="polite">
          <div class="hud-item">
            剩余时间
            <strong id="hud-time">90.0s</strong>
          </div>
          <div class="hud-item">
            我的分数
            <strong id="hud-score">0</strong>
          </div>
          <div class="hud-item">
            排名
            <strong id="hud-rank">1 / 4</strong>
          </div>
          <div class="hud-item">
            冲刺冷却
            <strong id="hud-dash">已就绪</strong>
          </div>
        </div>
        <div class="controls">
          <div>
            <strong>操作说明</strong>
            <ul>
              <li>
                <span class="key">WASD</span>
                或
                <span class="key">方向键</span>
                ：移动蛋仔
              </li>
              <li>
                <span class="key">空格键</span>
                ：冲刺撞击（击退对手并抢夺 FigureYa 图稿）
              </li>
              <li>
                <span class="key">R</span>
                ：立即重新开始
              </li>
            </ul>
          </div>
          <div>
            <strong>胜利条件</strong>
            <ul>
              <li>90 秒内收集尽可能多的 FigureYa 图稿</li>
              <li>图稿得分：普通 +10，巨型 +25</li>
              <li>撞飞对手可偷取 6 分，被撞会掉 6 分</li>
            </ul>
          </div>
        </div>
        <div class="notice" role="note">
          <strong>我的角色：</strong> 科研蛋（淡黄色蛋仔，名字上方标记“科研蛋”）
        </div>
        <div class="canvas-wrapper">
          <canvas
            id="game"
            width="960"
            height="600"
            aria-label="蛋仔派对游戏画布"
          ></canvas>
        </div>
      </div>
    </div>
    <div class="toast" id="toast" role="status" aria-live="polite"></div>
    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const hudTime = document.getElementById("hud-time");
      const hudScore = document.getElementById("hud-score");
      const hudRank = document.getElementById("hud-rank");
      const hudDash = document.getElementById("hud-dash");
      const toast = document.getElementById("toast");

      const figureGalleryFiles = [
        "FigureYa108RNAseqChIP.webp",
        "FigureYa115cofactor.webp",
        "FigureYa121MethCGIcluster.webp",
        "FigureYa233genepair.webp",
        "FigureYa285scRNA_monocle.webp",
        "FigureYa323STpathseq.webp",
      ];
      const figureGallery = figureGalleryFiles
        .map((file) => {
          const img = new Image();
          img.src = `./gallery_compress/${file}`;
          img.alt = file;
          return img;
        })
        .filter(Boolean);

      function getRandomFigureImage() {
        if (!figureGallery.length) return null;
        const index = Math.floor(Math.random() * figureGallery.length);
        return figureGallery[index];
      }

      const config = {
        width: canvas.width,
        height: canvas.height,
        arenaRadius: 260,
        arenaPadding: 70,
        maxTime: 90,
        playerSpeed: 600,
        aiBaseSpeed: 320,
        friction: 0.94,
        dashSpeed: 880,
        dashDuration: 0.26,
        dashCooldown: 4.2,
        knockBack: 420,
        starLifetime: [6, 10],
        megaStarInterval: [16, 26],
        baseStarValue: 10,
        megaStarValue: 25,
        stealValue: 6,
        starRadius: 14,
        megaStarRadius: 26,
        eggs: 4,
      };

      const state = {
        time: config.maxTime,
        running: false,
        lastFrame: 0,
        keys: new Set(),
        player: null,
        eggs: [],
        stars: [],
        megaTimer: 0,
      };

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function randRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function showToast(message, duration = 1600) {
        toast.textContent = message;
        toast.classList.add("show");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove("show"), duration);
      }

      function createEgg({ x, y, hue, isPlayer = false, name }) {
        return {
          x,
          y,
          vx: 0,
          vy: 0,
          radius: 28,
          hue,
          isPlayer,
          score: 0,
          dashCooldown: 0,
          dashTimer: 0,
          name,
          ai: {
            target: null,
            changeTimer: randRange(1.6, 3.2),
          },
        };
      }

      function resetGame() {
        state.time = config.maxTime;
        state.running = true;
        state.lastFrame = performance.now();
        state.eggs = [];
        state.stars = [];
        state.megaTimer = randRange(...config.megaStarInterval);

        const centerX = config.width / 2;
        const centerY = config.height / 2;
        const ringRadius = config.arenaRadius + 30;
        const colors = [36, 330, 200, 120];
        const names = ["科研蛋", "奶黄蛋", "紫薯蛋", "抹茶蛋"];

        for (let i = 0; i < config.eggs; i++) {
          const angle = (Math.PI * 2 * i) / config.eggs;
          const x = centerX + Math.cos(angle) * ringRadius;
          const y = centerY + Math.sin(angle) * ringRadius;
          const egg = createEgg({
            x,
            y,
            hue: colors[i % colors.length],
            isPlayer: i === 0,
            name: names[i % names.length],
          });
          if (egg.isPlayer) {
            state.player = egg;
          }
          state.eggs.push(egg);
        }

        spawnInitialStars();
        showToast("派对开始！冲刺抢夺 FigureYa 图稿，注意别被撞飞！");
        requestAnimationFrame(loop);
      }

      function spawnInitialStars() {
        state.stars = [];
        for (let i = 0; i < 12; i++) {
          state.stars.push(createStar());
        }
      }

      function createStar(isMega = false) {
        const angle = Math.random() * Math.PI * 2;
        const radius = randRange(40, config.arenaRadius - 30);
        const centerX = config.width / 2;
        const centerY = config.height / 2;
        return {
          x: centerX + Math.cos(angle) * radius,
          y: centerY + Math.sin(angle) * radius,
          radius: isMega ? config.megaStarRadius : config.starRadius,
          value: isMega ? config.megaStarValue : config.baseStarValue,
          life: randRange(...config.starLifetime),
          rotate: Math.random() * Math.PI * 2,
          rotateSpeed: randRange(-1, 1) * 0.8,
          pulsate: Math.random() * Math.PI * 2,
          isMega,
          texture: getRandomFigureImage(),
        };
      }

      function update(dt) {
        if (!state.running) return;

        state.time = Math.max(0, state.time - dt);
        if (state.time === 0) {
          state.running = false;
          announceResult();
        }

        updatePlayerInput(dt);
        updateEggs(dt);
        updateStars(dt);
        updateHUD();
      }

      function updatePlayerInput(dt) {
        const player = state.player;
        if (!player) return;

        let inputX = 0;
        let inputY = 0;
        if (state.keys.has("ArrowUp") || state.keys.has("KeyW")) inputY -= 1;
        if (state.keys.has("ArrowDown") || state.keys.has("KeyS")) inputY += 1;
        if (state.keys.has("ArrowLeft") || state.keys.has("KeyA")) inputX -= 1;
        if (state.keys.has("ArrowRight") || state.keys.has("KeyD")) inputX += 1;

        if (inputX !== 0 || inputY !== 0) {
          const len = Math.hypot(inputX, inputY);
          inputX /= len;
          inputY /= len;
          player.vx += inputX * config.playerSpeed * dt;
          player.vy += inputY * config.playerSpeed * dt;
        }
      }

      function updateEggs(dt) {
        const centerX = config.width / 2;
        const centerY = config.height / 2;
        const arenaRadius = config.arenaRadius;

        state.eggs.forEach((egg) => {
          if (!egg.isPlayer) {
            updateAI(egg, dt);
          }

          if (egg.dashTimer > 0) {
            egg.dashTimer = Math.max(0, egg.dashTimer - dt);
          } else {
            egg.vx *= egg.isPlayer ? config.friction : 0.9;
            egg.vy *= egg.isPlayer ? config.friction : 0.9;
          }

          egg.x += egg.vx * dt;
          egg.y += egg.vy * dt;

          const dx = egg.x - centerX;
          const dy = egg.y - centerY;
          const distance = Math.hypot(dx, dy);
          if (distance > arenaRadius - egg.radius) {
            const normalX = dx / distance;
            const normalY = dy / distance;
            egg.x = centerX + normalX * (arenaRadius - egg.radius);
            egg.y = centerY + normalY * (arenaRadius - egg.radius);
            const bounce = -(egg.vx * normalX + egg.vy * normalY) * 1.2;
            egg.vx += normalX * bounce;
            egg.vy += normalY * bounce;
          }

          egg.dashCooldown = Math.max(0, egg.dashCooldown - dt);
        });

        handleEggCollisions();
      }

      function updateAI(egg, dt) {
        const targets = [...state.stars];
        if (state.player) {
          targets.push(state.player);
        }

        egg.ai.changeTimer -= dt;
        if (
          egg.ai.changeTimer <= 0 ||
          !egg.ai.target ||
          egg.ai.target.life <= 0
        ) {
          egg.ai.changeTimer = randRange(1.4, 2.8);
          egg.ai.target = targets.sort((a, b) => {
            const priorityA = getTargetPriority(egg, a);
            const priorityB = getTargetPriority(egg, b);
            return priorityB - priorityA;
          })[0];
        }

        if (!egg.ai.target) return;

        const targetX = egg.ai.target.x;
        const targetY = egg.ai.target.y;
        const dx = targetX - egg.x;
        const dy = targetY - egg.y;
        const distance = Math.hypot(dx, dy) || 1;
        const speed = lerp(config.aiBaseSpeed, config.playerSpeed, Math.random() * 0.1);

        egg.vx += (dx / distance) * speed * dt;
        egg.vy += (dy / distance) * speed * dt;

        if (
          !egg.ai.target.isMega &&
          egg.dashCooldown === 0 &&
          distance < 160 &&
          Math.random() < 0.015
        ) {
          triggerDash(egg, dx / distance, dy / distance);
        }
      }

      function getTargetPriority(egg, target) {
        if (!target) return 0;
        const dx = target.x - egg.x;
        const dy = target.y - egg.y;
        const distance = Math.hypot(dx, dy);
        const isStar = typeof target.value === "number";
        let priority = isStar ? target.value : 10;
        if (!isStar && target.isPlayer) priority += 12;
        return priority / Math.max(24, distance);
      }

      function triggerDash(egg, dirX, dirY) {
        egg.dashTimer = config.dashDuration;
        egg.dashCooldown = config.dashCooldown;
        egg.vx = dirX * config.dashSpeed;
        egg.vy = dirY * config.dashSpeed;
        if (egg.isPlayer) {
          hudDash.textContent = "冲刺中...";
        }
      }

      function handleEggCollisions() {
        for (let i = 0; i < state.eggs.length; i++) {
          for (let j = i + 1; j < state.eggs.length; j++) {
            const a = state.eggs[i];
            const b = state.eggs[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            const minDist = a.radius + b.radius;
            if (dist < minDist) {
              const overlap = minDist - dist;
              const nx = dx / dist;
              const ny = dy / dist;

              a.x -= nx * overlap * 0.5;
              a.y -= ny * overlap * 0.5;
              b.x += nx * overlap * 0.5;
              b.y += ny * overlap * 0.5;

              const relativeSpeed =
                (b.vx - a.vx) * nx + (b.vy - a.vy) * ny;
              if (relativeSpeed > 0) {
                const impulse = relativeSpeed * 0.8;
                a.vx += impulse * nx;
                a.vy += impulse * ny;
                b.vx -= impulse * nx;
                b.vy -= impulse * ny;
              }

              const aDashing = a.dashTimer > 0;
              const bDashing = b.dashTimer > 0;
              if (aDashing !== bDashing) {
                const winner = aDashing ? a : b;
                const loser = aDashing ? b : a;
                const steal = Math.min(config.stealValue, Math.max(0, loser.score));
                loser.score = Math.max(0, loser.score - steal);
                winner.score += steal;
                loser.vx -= nx * config.knockBack;
                loser.vy -= ny * config.knockBack;
                winner.vx += nx * (config.knockBack / 2);
                winner.vy += ny * (config.knockBack / 2);
                if (winner.isPlayer) {
                  showToast(`撞飞 ${loser.name}，偷走 ${steal} 分！`);
                } else if (loser.isPlayer) {
                  showToast(`小心！被 ${winner.name} 撞飞，失去 ${steal} 分...`);
                  hudDash.textContent = "冲刺冷却中...";
                }
              }
            }
          }
        }
      }

      function updateStars(dt) {
        state.stars.forEach((star) => {
          star.life -= dt;
          star.rotate += star.rotateSpeed * dt;
          star.pulsate += dt * (star.isMega ? 2.4 : 1.6);
        });
        state.stars = state.stars.filter((star) => star.life > 0);
        while (state.stars.length < 10) {
          state.stars.push(createStar());
        }

        state.megaTimer -= dt;
        if (state.megaTimer <= 0) {
          state.stars.push(createStar(true));
          state.megaTimer = randRange(...config.megaStarInterval);
          showToast("巨型 FigureYa 图出现啦！快抢先夺取高分！");
        }

        state.eggs.forEach((egg) => {
          for (let i = state.stars.length - 1; i >= 0; i--) {
            const star = state.stars[i];
            const dx = star.x - egg.x;
            const dy = star.y - egg.y;
            const dist = Math.hypot(dx, dy);
            if (dist < egg.radius + star.radius - 6) {
              egg.score += star.value;
              state.stars.splice(i, 1);
              if (egg.isPlayer) {
                showToast(
                  star.isMega ? "巨型 FigureYa 图 +25 分！" : "收集 FigureYa 图 +10 分！",
                  1200,
                );
              }
            }
          }
        });
      }

      function updateHUD() {
        hudTime.textContent = `${state.time.toFixed(1)}s`;
        hudScore.textContent = state.player.score;

        const sorted = [...state.eggs].sort((a, b) => b.score - a.score);
        const playerRank = sorted.indexOf(state.player) + 1;
        hudRank.textContent = `${playerRank} / ${state.eggs.length}`;

        if (state.player.dashCooldown === 0) {
          hudDash.textContent = state.player.dashTimer > 0 ? "冲刺中..." : "已就绪";
          hudDash.style.color =
            state.player.dashTimer > 0 ? "var(--danger)" : "var(--success)";
        } else {
          hudDash.textContent = `冷却：${state.player.dashCooldown.toFixed(1)}s`;
          hudDash.style.color = "var(--muted)";
        }
      }

      function announceResult() {
        const sorted = [...state.eggs].sort((a, b) => b.score - a.score);
        const playerRank = sorted.indexOf(state.player) + 1;
        const message =
          playerRank === 1
            ? `冠军！你以 ${state.player.score} 分夺得头名！`
            : `比赛结束，你排名第 ${playerRank}，得分 ${state.player.score}。再冲一次试试？`;
        showToast(message, 2800);
      }

      function draw() {
        ctx.clearRect(0, 0, config.width, config.height);

        ctx.save();
        ctx.translate(0.5, 0.5);

        drawBackground();

        const centerX = config.width / 2;
        const centerY = config.height / 2;
        ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
        ctx.beginPath();
        ctx.arc(centerX, centerY, config.arenaRadius + 46, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(91, 109, 255, 0.1)";
        ctx.beginPath();
        ctx.arc(centerX, centerY, config.arenaRadius + 30, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(91, 109, 255, 0.4)";
        ctx.lineWidth = 12;
        ctx.beginPath();
        ctx.arc(centerX, centerY, config.arenaRadius, 0, Math.PI * 2);
        ctx.stroke();

        drawStars();
        drawEggs();

        ctx.restore();
      }

      function drawBackground() {
        const gridSize = 80;
        const offset = state.backgroundOffset % gridSize;
        ctx.strokeStyle = "rgba(91, 109, 255, 0.15)";
        ctx.lineWidth = 1;
        for (let x = -gridSize; x <= config.width + gridSize; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(Math.round(x + offset), 0);
          ctx.lineTo(Math.round(x + offset), config.height);
          ctx.stroke();
        }
        for (let y = -gridSize; y <= config.height + gridSize; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, Math.round(y + offset));
          ctx.lineTo(config.width, Math.round(y + offset));
          ctx.stroke();
        }
      }

      function drawStars() {
        state.stars.forEach((star) => {
          const pulsate = star.isMega ? Math.sin(star.pulsate) * 8 : Math.sin(star.pulsate) * 4;
          const radius = star.radius + pulsate;
          const texture = star.texture;
          const size = radius * 2;
          ctx.save();
          ctx.translate(Math.round(star.x) + 0.5, Math.round(star.y) + 0.5);
          ctx.rotate(star.rotate);
          if (texture && texture.complete) {
            const megaScale = star.isMega ? 1.15 : 1;
            const finalSize = size * megaScale;
            ctx.drawImage(texture, -finalSize / 2, -finalSize / 2, finalSize, finalSize);
          } else {
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = star.isMega ? "rgba(91, 109, 255, 0.35)" : "rgba(91, 109, 255, 0.25)";
            ctx.fill();
          }
          if (star.isMega) {
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
            ctx.arc(0, 0, radius * 0.85, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();
        });
      }

      function drawEggs() {
        state.eggs.forEach((egg) => {
          const size = egg.radius;
          ctx.save();
          ctx.translate(Math.round(egg.x) + 0.5, Math.round(egg.y) + 0.5);
          const squash = 1 + Math.min(0.12, Math.hypot(egg.vx, egg.vy) / 600);
          ctx.scale(1, squash);
          ctx.beginPath();
          ctx.ellipse(0, 0, size, size * 1.2, 0, 0, Math.PI * 2);
          ctx.fillStyle = `hsl(${egg.hue}, 85%, 82%)`;
          ctx.fill();
          ctx.lineWidth = 4;
          ctx.strokeStyle = `hsl(${egg.hue}, 70%, 70%)`;
          ctx.stroke();

          ctx.scale(1, 1 / squash);
          ctx.beginPath();
          ctx.ellipse(-6, -4, size * 0.2, size * 0.24, 0, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
          ctx.fill();

          ctx.font = "14px Nunito";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.fillStyle = "rgba(0,0,0,0.45)";
          ctx.fillText(egg.name, 0, size * 1.2 + 8);
          ctx.restore();
        });
      }

      function loop(now) {
        if (!state.running) {
          draw();
          return;
        }
        const dt = Math.min(0.05, (now - state.lastFrame) / 1000);
        state.lastFrame = now;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      function shouldBlockDefault(code) {
        return (
          code === "Space" ||
          code === "ArrowUp" ||
          code === "ArrowDown" ||
          code === "ArrowLeft" ||
          code === "ArrowRight"
        );
      }

      document.addEventListener("keydown", (event) => {
        if (shouldBlockDefault(event.code)) {
          event.preventDefault();
        }
        if (event.code === "KeyR") {
          resetGame();
          return;
        }
        state.keys.add(event.code);
        if (event.code === "Space") {
          if (state.player && state.player.dashCooldown === 0) {
            const dirX = state.player.vx || 1;
            const dirY = state.player.vy;
            const len = Math.hypot(dirX, dirY) || 1;
            triggerDash(state.player, dirX / len, dirY / len);
            showToast("冲刺出击！");
          }
        }
      });

      document.addEventListener("keyup", (event) => {
        if (shouldBlockDefault(event.code)) {
          event.preventDefault();
        }
        state.keys.delete(event.code);
      });

      window.addEventListener("blur", () => {
        state.keys.clear();
      });

      resetGame();
    </script>
  </body>
</html>

