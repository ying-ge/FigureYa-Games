<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Link Up Ideas - FigureYa match puzzle">
    <title>Link Up Ideas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.85);
            color: #764ba2;
            font-weight: bold;
            text-decoration: none;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin-bottom: 16px;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0,0,0,0.24);
        }

        h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .game-controls {
            background: white;
            padding: 15px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .difficulty-selector label {
            font-weight: bold;
            color: #333;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .difficulty-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .difficulty-btn.active {
            background: #667eea;
            color: white;
        }

        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: bold;
            color: #333;
        }

        .timer {
            font-size: 1.2em;
            color: #e74c3c;
        }

        .score {
            font-size: 1.2em;
            color: #27ae60;
        }

        .moves {
            font-size: 1.2em;
            color: #3498db;
        }

        .game-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .game-board {
            display: grid;
            gap: 6px;
            max-width: min(90vw, 800px);
            margin: 0 auto;
            justify-content: center;
        }

        .tile {
            width: clamp(50px, 8vw, 80px);
            height: clamp(50px, 8vw, 80px);
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        @media (max-width: 768px) {
            .game-board {
                gap: 4px;
            }
        }

        .tile:hover:not(.empty) {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        .tile.selected {
            border-color: #e74c3c;
            border-width: 3px;
            transform: translateY(-8px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
        }

        .tile.matched {
            animation: matchAnimation 0.5s ease;
            opacity: 0;
            pointer-events: none;
        }

        .tile.empty {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1) rotate(0deg);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
            font-size: 16px;
        }

        .btn-start {
            background: #27ae60;
        }

        .btn-start:hover {
            background: #2ecc71;
            transform: translateY(-2px);
        }

        .btn-hint {
            background: #f39c12;
        }

        .btn-hint:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn-restart {
            background: #e74c3c;
        }

        .btn-restart:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .game-over h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-over p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .connection-line {
            position: absolute;
            background: #e74c3c;
            z-index: 100;
            pointer-events: none;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .tile {
                width: 60px;
                height: 60px;
            }

            .game-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .difficulty-selector {
                justify-content: center;
            }

            .game-info {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>
    <header>
        <a class="back-button" href="../index.html">‚Üê More Games</a>
        <h1>üéÆ Link Up Ideas</h1>
        <p>Find matching FigureYa tiles and connect them with up to three straight lines!</p>
    </header>

    <section class="game-controls">
        <div class="difficulty-selector">
            <label>Difficulty:</label>
            <button class="difficulty-btn active" data-level="easy">Easy</button>
            <button class="difficulty-btn" data-level="medium">Medium</button>
            <button class="difficulty-btn" data-level="hard">Hard</button>
                    </div>

        <div class="game-info">
            <div class="timer">Time: <span id="time">00:00</span></div>
            <div class="score">Score: <span id="score">0</span></div>
            <div class="moves">Moves: <span id="moves">0</span></div>
        </div>
    </section>

    <section class="game-container">
        <div class="game-board" id="gameBoard"></div>
    </section>

    <section class="action-buttons">
        <button class="btn btn-start" id="startBtn">Start</button>
        <button class="btn btn-hint" id="hintBtn">Hint (3)</button>
        <button class="btn btn-restart" id="restartBtn">Restart</button>
    </section>

        <h2 id="gameOverTitle">Game Over!</h2>
        <p id="gameOverMessage"></p>
        <button class="btn btn-start" onclick="restartGame()">Play Again</button>
    </div>

    <div class="overlay" id="overlay"></div>

    <script>
        class LinkUpPuzzle {
            constructor() {
                this.board = [];
                this.rows = 0;
                this.cols = 0;
                this.selectedTiles = [];
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;
                this.timer = null;
                this.gameStarted = false;
                this.difficulty = 'easy';
                this.imagePaths = [];
                this.availableImages = [];

                this.difficultySettings = {
                    easy: { rows: 4, cols: 6, pairs: 12 },      // 4√ó6 grid, 12 pairs
                    medium: { rows: 6, cols: 8, pairs: 24 },    // 6√ó8 grid, 24 pairs
                    hard: { rows: 8, cols: 8, pairs: 32 }       // 8√ó8 grid, 32 pairs (reduced complexity)
                };

                // Precomputed board cache (kept small to save memory)
                // Hard-mode boards are hard-coded and ready to use on load
                this.precomputedBoards = {
                    easy: [],
                    medium: [],
                    hard: this.getHardModeBoards() // supplied by hard-coded layouts
                };
                
                // Event handler references (for cleanup)
                this.boardClickHandler = null;

                this.initializeEventListeners();
                this.loadImagePaths();
                
                // Defer precomputation so the UI can mount first
                // Hard layouts already baked in; no precomputation needed
                setTimeout(() => this.precomputeBoards(), 100);
            }

            loadImagePaths() {
                // Master list of 186 FigureYa thumbnails; we sample from this each round
                this.imagePaths = [
                    'gallery_compress/FigureYa106immunotherapy.webp',
                    'gallery_compress/FigureYa107ChIPheatmap.webp',
                    'gallery_compress/FigureYa108RNAseqChIP.webp',
                    'gallery_compress/FigureYa10chromosomeV2_update.webp',
                    'gallery_compress/FigureYa111markerGene.webp',
                    'gallery_compress/FigureYa112venn.webp',
                    'gallery_compress/FigureYa114ternaryCluster.webp',
                    'gallery_compress/FigureYa115cofactor.webp',
                    'gallery_compress/FigureYa121MethCGIcluster.webp',
                    'gallery_compress/FigureYa123mutVSexpr.webp',
                    'gallery_compress/FigureYa124AssociationHeatmap.webp',
                    'gallery_compress/FigureYa125FishertestV2.webp',
                    'gallery_compress/FigureYa126CorrelationHeatmap.webp',
                    'gallery_compress/FigureYa127HeatmapPie.webp',
                    'gallery_compress/FigureYa131CMap_update.webp',
                    'gallery_compress/FigureYa132alteration.webp',
                    'gallery_compress/FigureYa135multiVolcano.webp',
                    'gallery_compress/FigureYa139TMB_titv.webp',
                    'gallery_compress/FigureYa13GSEA_Java_update.webp',
                    'gallery_compress/FigureYa140mosaicpie.webp',
                    'gallery_compress/FigureYa141risk.webp',
                    'gallery_compress/FigureYa142circosBar.webp',
                    'gallery_compress/FigureYa143survCor.webp',
                    'gallery_compress/FigureYa144DiagHeatmap.webp',
                    'gallery_compress/FigureYa145target.webp',
                    'gallery_compress/FigureYa147Plus_STRING.webp',
                    'gallery_compress/FigureYa148SimpleDendrogram.webp',
                    'gallery_compress/FigureYa149rankHeatmap.webp',
                    'gallery_compress/FigureYa14circos.webp',
                    'gallery_compress/FigureYa152DouleCorPlot.webp',
                    'gallery_compress/FigureYa153ccgraph.webp',
                    'gallery_compress/FigureYa157ChIPpvalue.webp',
                    'gallery_compress/FigureYa158MutationPattern.webp',
                    'gallery_compress/FigureYa15WGCNA.webp',
                    'gallery_compress/FigureYa160scGSVA.webp',
                    'gallery_compress/FigureYa161stemness.webp',
                    'gallery_compress/FigureYa162boxViolin.webp',
                    'gallery_compress/FigureYa163twoVarCor_update.webp',
                    'gallery_compress/FigureYa164PCA3D.webp',
                    'gallery_compress/FigureYa168legoplot.webp',
                    'gallery_compress/FigureYa169sigHeatmap.webp',
                    'gallery_compress/FigureYa170ImmuLncRNA.webp',
                    'gallery_compress/FigureYa173fancybar.webp',
                    'gallery_compress/FigureYa175quadrant.webp',
                    'gallery_compress/FigureYa176BlandAltman.webp',
                    'gallery_compress/FigureYa177RNAvelocity.webp',
                    'gallery_compress/FigureYa179AMDAplot.webp',
                    'gallery_compress/FigureYa17WGCNA_heatmap.webp',
                    'gallery_compress/FigureYa180FGAplotV2.webp',
                    'gallery_compress/FigureYa181multiCorrelation.webp',
                    'gallery_compress/FigureYa182RFSurvV2.webp',
                    'gallery_compress/FigureYa186swimmerplot.webp',
                    'gallery_compress/FigureYa18oncoplot_update.webp',
                    'gallery_compress/FigureYa194pySCENIC.webp',
                    'gallery_compress/FigureYa195PanPaire.webp',
                    'gallery_compress/FigureYa196PanPie.webp',
                    'gallery_compress/FigureYa196Plus_PanPie.webp',
                    'gallery_compress/FigureYa199crosslink.webp',
                    'gallery_compress/FigureYa19Lollipop.webp',
                    'gallery_compress/FigureYa200pairwiseAUC.webp',
                    'gallery_compress/FigureYa202consensusGene.webp',
                    'gallery_compress/FigureYa203ComBat.webp',
                    'gallery_compress/FigureYa204PCAscore.webp',
                    'gallery_compress/FigureYa205immunophenoscore_update.webp',
                    'gallery_compress/FigureYa206scHeatmap.webp',
                    'gallery_compress/FigureYa208FPI.webp',
                    'gallery_compress/FigureYa209batchEnrich.webp',
                    'gallery_compress/FigureYa210survivalScape.webp',
                    'gallery_compress/FigureYa211multiCohortImmSubtype.webp',
                    'gallery_compress/FigureYa212drugTargetV2.webp',
                    'gallery_compress/FigureYa213customizeHeatmap.webp',
                    'gallery_compress/FigureYa214KEGG_hierarchyV2.webp',
                    'gallery_compress/FigureYa215DNAage.webp',
                    'gallery_compress/FigureYa219GMM.webp',
                    'gallery_compress/FigureYa222PCAgene.webp',
                    'gallery_compress/FigureYa224scMarker.webp',
                    'gallery_compress/FigureYa225GiViTl.webp',
                    'gallery_compress/FigureYa227boxdensity.webp',
                    'gallery_compress/FigureYa228linkCor.webp',
                    'gallery_compress/FigureYa229PCOA.webp',
                    'gallery_compress/FigureYa230immunelandscape.webp',
                    'gallery_compress/FigureYa232scRankHeatmap.webp',
                    'gallery_compress/FigureYa233genepair.webp',
                    'gallery_compress/FigureYa234panImmune.webp',
                    'gallery_compress/FigureYa235scDEG.webp',
                    'gallery_compress/FigureYa236circGroup.webp',
                    'gallery_compress/FigureYa238corRiskMut.webp',
                    'gallery_compress/FigureYa239ST_PDAC.webp',
                    'gallery_compress/FigureYa240CRISPR.webp',
                    'gallery_compress/FigureYa242corMethExpr.webp',
                    'gallery_compress/FigureYa243scMarkerGroupHeatmap.webp',
                    'gallery_compress/FigureYa244PCAPlot.webp',
                    'gallery_compress/FigureYa245VarDecompose.webp',
                    'gallery_compress/FigureYa248MutLandscape.webp',
                    'gallery_compress/FigureYa249Regulon.webp',
                    'gallery_compress/FigureYa252mclust.webp',
                    'gallery_compress/FigureYa254scViolin.webp',
                    'gallery_compress/FigureYa255TIME.webp',
                    'gallery_compress/FigureYa256panelLink.webp',
                    'gallery_compress/FigureYa259circLink.webp',
                    'gallery_compress/FigureYa25Plus_Sankey_py.webp',
                    'gallery_compress/FigureYa261circGene.webp',
                    'gallery_compress/FigureYa262GDC.webp',
                    'gallery_compress/FigureYa263panDiff.webp',
                    'gallery_compress/FigureYa264epiImmune.webp',
                    'gallery_compress/FigureYa266panHeatmap.webp',
                    'gallery_compress/FigureYa267scCellChat.webp',
                    'gallery_compress/FigureYa26circos_R.webp',
                    'gallery_compress/FigureYa272scBulkCCCI.webp',
                    'gallery_compress/FigureYa275scAUCell.webp',
                    'gallery_compress/FigureYa277Immunomodulator.webp',
                    'gallery_compress/FigureYa280TMEofSTS.webp',
                    'gallery_compress/FigureYa284pairwiseLogrank.webp',
                    'gallery_compress/FigureYa285scRNA_monocle.webp',
                    'gallery_compress/FigureYa286ExprCorORR.webp',
                    'gallery_compress/FigureYa288MutualExclusivity.webp',
                    'gallery_compress/FigureYa289TILSig.webp',
                    'gallery_compress/FigureYa290BarGraph.webp',
                    'gallery_compress/FigureYa291PancanProgSigatureV2.webp',
                    'gallery_compress/FigureYa296VIPER.webp',
                    'gallery_compress/FigureYa2ggtree+pheatmap+msa.webp',
                    'gallery_compress/FigureYa300pancanCor.webp',
                    'gallery_compress/FigureYa301scCoExpr.webp',
                    'gallery_compress/FigureYa302NTPPAM.webp',
                    'gallery_compress/FigureYa303panCircos.webp',
                    'gallery_compress/FigureYa305PMAPscore.webp',
                    'gallery_compress/FigureYa306slingshot.webp',
                    'gallery_compress/FigureYa307CNVHeatmap.webp',
                    'gallery_compress/FigureYa309cell2location.webp',
                    'gallery_compress/FigureYa30nomogram_update.webp',
                    'gallery_compress/FigureYa310CPDBChordGramV2.webp',
                    'gallery_compress/FigureYa311PAM50Heatmap.webp',
                    'gallery_compress/FigureYa312CellPreference.webp',
                    'gallery_compress/FigureYa31lasso_update.webp',
                    'gallery_compress/FigureYa320ClontypeHeatmap.webp',
                    'gallery_compress/FigureYa323STpathseq.webp',
                    'gallery_compress/FigureYa33DCA_update.webp',
                    'gallery_compress/FigureYa36nSurvV3.webp',
                    'gallery_compress/FigureYa37correlationV2_update.webp',
                    'gallery_compress/FigureYa38PCA.webp',
                    'gallery_compress/FigureYa39bar.webp',
                    'gallery_compress/FigureYa3genomeView.webp',
                    'gallery_compress/FigureYa40lineage.webp',
                    'gallery_compress/FigureYa42oncoprintV2_update.webp',
                    'gallery_compress/FigureYa43ManhattanV2.webp',
                    'gallery_compress/FigureYa44profile.webp',
                    'gallery_compress/FigureYa52GOplot.webp',
                    'gallery_compress/FigureYa55panCancer_violinV2.webp',
                    'gallery_compress/FigureYa55plus_pancancer_boxplot.webp',
                    'gallery_compress/FigureYa57profile_1bw.webp',
                    'gallery_compress/FigureYa59volcanoV2.webp',
                    'gallery_compress/FigureYa5bubbles.webp',
                    'gallery_compress/FigureYa60GSEA_clusterProfilerV2.webp',
                    'gallery_compress/FigureYa61GSVA.webp',
                    'gallery_compress/FigureYa62twoAxis.webp',
                    'gallery_compress/FigureYa64triangle.webp',
                    'gallery_compress/FigureYa67phastCons.webp',
                    'gallery_compress/FigureYa68friendsV2.webp',
                    'gallery_compress/FigureYa69cancerSubtype.webp',
                    'gallery_compress/FigureYa6rHRsV2.webp',
                    'gallery_compress/FigureYa70mutationEvents.webp',
                    'gallery_compress/FigureYa71ssGSEA_update.webp',
                    'gallery_compress/FigureYa73batchCorrelation.webp',
                    'gallery_compress/FigureYa74OmicCircos.webp',
                    'gallery_compress/FigureYa75bubble_volcano.webp',
                    'gallery_compress/FigureYa76corrgram.webp',
                    'gallery_compress/FigureYa78gganatogram.webp',
                    'gallery_compress/FigureYa79CNV.webp',
                    'gallery_compress/FigureYa80GOclustering.webp',
                    'gallery_compress/FigureYa81immune_network.webp',
                    'gallery_compress/FigureYa82IGVzoom.webp',
                    'gallery_compress/FigureYa83enrichment.webp',
                    'gallery_compress/FigureYa84roast.webp',
                    'gallery_compress/FigureYa86SNPmotif.webp',
                    'gallery_compress/FigureYa87fish.webp',
                    'gallery_compress/FigureYa88DAVIDkappa.webp',
                    'gallery_compress/FigureYa89ggplotCirco.webp',
                    'gallery_compress/FigureYa8radar.webp',
                    'gallery_compress/FigureYa92immune_gene_update.webp',
                    'gallery_compress/FigureYa93UMAP.webp',
                    'gallery_compress/FigureYa95pairwise.webp',
                    'gallery_compress/FigureYa96R2.webp',
                    'gallery_compress/FigureYa97correlationV3.webp',
                    'gallery_compress/FigureYa99smoothHRv2.webp',
                    'gallery_compress/FigureYa9heatmap.webp',
                ];
            }

            getRandomImages(count) {
                // Pick a unique set of thumbnails for this round
                const selectedImages = [];
                const usedIndices = new Set();

                for (let i = 0; i < count; i++) {
                    let randomIndex;
                    do {
                        randomIndex = Math.floor(Math.random() * this.imagePaths.length);
                    } while (usedIndices.has(randomIndex));

                    usedIndices.add(randomIndex);
                    selectedImages.push(this.imagePaths[randomIndex]);
                }

                return selectedImages;
            }

            // Hard-coded 8√ó8 layouts for hard mode
            // Each entry should be an 8√ó8 matrix of image paths or null
            getHardModeBoards() {
                // Placeholder: populate with generated layouts if available
                return [
                    // Layout slots left intentionally blank
                ];
            }

            initializeEventListeners() {
                const startBtn = document.getElementById('startBtn');
                const restartBtn = document.getElementById('restartBtn');
                const hintBtn = document.getElementById('hintBtn');

                if (!startBtn || !restartBtn || !hintBtn) {
                    // DOM not ready yet, wait for load
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', () => this.initializeEventListeners());
                        return;
                    }
                    return;
                }

                startBtn.addEventListener('click', () => this.startGame());
                restartBtn.addEventListener('click', () => this.restartGame());
                hintBtn.addEventListener('click', () => this.showHint());

                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.changeDifficulty(e);
                    });
                });
            }

            changeDifficulty(e) {
                // Handle clicks bubbling from child elements
                let button = e.target;
                while (button && !button.classList.contains('difficulty-btn')) {
                    button = button.parentElement;
                }
                
                if (!button) {
                    button = e.target.closest('.difficulty-btn');
                }
                
                if (!button) return;
                
                document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                this.difficulty = button.dataset.level;

                // Restart immediately if a round is in progress
                if (this.gameStarted) {
                    this.restartGame();
                }
            }

            startGame() {
                try {
                    const settings = this.difficultySettings[this.difficulty];
                    if (!settings) {
                        alert('Invalid difficulty. Please refresh the page and try again.');
                        return;
                    }
                    this.rows = settings.rows;
                    this.cols = settings.cols;
                    this.pairs = settings.pairs;

                    this.initializeGame();
                } catch (error) {
                    alert('Failed to start game: ' + error.message);
                }
            }

            initializeGame() {
                // Prefer cached layouts when available
                const cachedBoards = this.precomputedBoards[this.difficulty];
                
                if (cachedBoards && cachedBoards.length > 0) {
                    // Pick a cached layout at random
                    const randomIndex = Math.floor(Math.random() * cachedBoards.length);
                    this.board = cachedBoards[randomIndex].map(row => row.map(cell => cell));
                    
                    // Optional: log hard-mode layout index for debugging
                    if (this.difficulty === 'hard') {
                        // console.log(`Hard layout #${randomIndex + 1}/${cachedBoards.length}`);
                    }
                } else {
                    // Generate a solvable board on the fly
                    // Hard mode should rarely hit this path
                    if (this.difficulty === 'hard') {
                        console.warn('Hard-mode layout cache not ready; generating on the fly.');
                    }
                    this.generateSolvableBoard();
                }
                
                this.renderBoard();
                this.gameStarted = true;
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;

                this.updateDisplay();
                this.startTimer();

                document.getElementById('hintBtn').textContent = `Hint (${this.hints})`;
            }

            // Precompute sample boards in the background
            precomputeBoards() {
                const difficulties = ['easy', 'medium'];
                const boardsPerDifficulty = {
                    easy: 2,     // fewer cached layouts to save memory
                    medium: 1    // keep footprint small
                };

                difficulties.forEach((difficulty, index) => {
                    const settings = this.difficultySettings[difficulty];
                    const targetCount = boardsPerDifficulty[difficulty];
                    
                    // Batch precomputation to avoid blocking the UI
                    let computed = 0;
                    let attempts = 0;
                    const maxAttemptsPerBoard = difficulty === 'hard' ? 100 : 50; // allow more retries for hard
                    
                    const computeNext = () => {
                        if (computed >= targetCount) {
                            if (difficulty === 'hard' && computed > 0) {
                                console.log(`${difficulty} layouts prepared (${computed}/${targetCount})`);
                            }
                            return;
                        }

                        // Temporarily adopt this difficulty while generating
                        const oldDifficulty = this.difficulty;
                        const oldRows = this.rows;
                        const oldCols = this.cols;
                        const oldPairs = this.pairs;
                        
                        this.difficulty = difficulty;
                        this.rows = settings.rows;
                        this.cols = settings.cols;
                        this.pairs = settings.pairs;

                        // Attempt to generate a solvable board
                        const board = this.generateSolvableBoardSync();
                        if (board) {
                            this.precomputedBoards[difficulty].push(board);
                            computed++;
                            attempts = 0;
                        } else {
                            attempts++;
                            // Give up after too many attempts so we don't stall
                            if (attempts >= maxAttemptsPerBoard) {
                                console.warn(`${difficulty} layout ${computed + 1} failed after ${attempts} attempts.`);
                            }
                        }

                        // Restore original settings
                        this.difficulty = oldDifficulty;
                        this.rows = oldRows;
                        this.cols = oldCols;
                        this.pairs = oldPairs;

                        // Schedule the next attempt without blocking the main thread
                        const delay = difficulty === 'hard' ? 50 : 10;
                        setTimeout(computeNext, delay);
                    };

                    // Slightly stagger start times so tasks don‚Äôt clash
                    const startDelay = difficulty === 'hard' ? 0 : (index * 2000);
                    setTimeout(computeNext, startDelay);
                });
            }

            // Synchronously generate a solvable board (used during precomputation)
            generateSolvableBoardSync() {
                let attempts = 0;
                // Hard mode gets more chances because it‚Äôs denser
                const maxAttempts = this.difficulty === 'hard' ? 100 : 50;
                
                while (attempts < maxAttempts) {
                    const testBoard = this.createBoard();
                    const tempBoard = this.board;
                    this.board = testBoard;
                    
                    const hasEnough = this.hasEnoughConnectablePairs();
                    if (hasEnough) {
                        const isSolvable = this.isSolvable();
                        if (isSolvable) {
                            this.board = tempBoard;
                            return testBoard.map(row => row.map(cell => cell));
                        }
                    }
                    
                    this.board = tempBoard;
                    attempts++;
                }
                
                return null; // Give up after exhausting attempts
            }

            // Generate a solvable board when no cached board is available
            generateSolvableBoard() {
                let attempts = 0;
                const maxAttempts = {
                    easy: 30,
                    medium: 50,
                    hard: 80
                }[this.difficulty] || 50;
                
                let bestBoard = null;
                let bestScore = 0;
                
                while (attempts < maxAttempts) {
                    const testBoard = this.createBoard();
                    const tempBoard = this.board;
                    this.board = testBoard;
                    
                    const hasEnough = this.hasEnoughConnectablePairs();
                    if (hasEnough) {
                        const isSolvable = this.isSolvable();
                        if (isSolvable) {
                            this.board = testBoard;
                            return;
                        }
                    }
                    
                    if (hasEnough) {
                        const pairs = new Map();
                        for (let i = 0; i < testBoard.length; i++) {
                            for (let j = 0; j < testBoard[i].length; j++) {
                                if (testBoard[i][j]) {
                                    const image = testBoard[i][j];
                                    if (!pairs.has(image)) {
                                        pairs.set(image, []);
                                    }
                                    pairs.get(image).push({row: i, col: j});
                                }
                            }
                        }
                        let estimatedCount = 0;
                        for (const [image, positions] of pairs.entries()) {
                            const pairCount = positions.length * (positions.length - 1) / 2;
                            estimatedCount += Math.floor(pairCount * 0.5);
                        }
                        
                        if (estimatedCount > bestScore) {
                            bestScore = estimatedCount;
                            bestBoard = testBoard.map(row => row.map(cell => cell));
                        }
                    }
                    
                    this.board = tempBoard;
                    attempts++;
                }
                
                if (attempts >= maxAttempts && bestBoard) {
                    this.board = bestBoard;
                } else if (attempts >= maxAttempts) {
                    this.board = this.createBoard();
                }
            }

            createBoard() {
                const totalTiles = this.rows * this.cols;
                const pairsNeeded = Math.min(this.pairs, Math.floor(totalTiles / 2));

                // Build paired image list
                const images = [];
                const selectedImages = this.getRandomImages(pairsNeeded);

                for (let i = 0; i < pairsNeeded; i++) {
                    images.push(selectedImages[i], selectedImages[i]); // duplicate to form a pair
                }

                // Fill remaining tiles with additional pairs if needed
                while (images.length < totalTiles && images.length < this.imagePaths.length * 2) {
                    const randomImage = this.imagePaths[Math.floor(Math.random() * this.imagePaths.length)];
                    images.push(randomImage, randomImage);
                }

                // Trim to the exact tile count
                while (images.length > totalTiles) {
                    images.pop();
                }

                // Shuffle images
                for (let i = images.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [images[i], images[j]] = [images[j], images[i]];
                }

                // Lay out into a 2D grid
                const board = [];
                let imageIndex = 0;

                for (let i = 0; i < this.rows; i++) {
                    board[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        board[i][j] = imageIndex < images.length ? images[imageIndex++] : null;
                    }
                }

                return board;
            }

            renderBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;

                // Use DocumentFragment to minimise reflows
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.dataset.row = i;
                        tile.dataset.col = j;

                        if (this.board[i][j]) {
                            const img = document.createElement('img');
                            img.src = this.board[i][j];
                            img.alt = 'Game Tile';
                            // Lazy load to reduce initial payload
                            img.loading = 'lazy';
                            // Pre-set sizing to avoid layout shifts
                            img.style.width = '100%';
                            img.style.height = '100%';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '6px';

                            // Hide failed images silently
                            img.onerror = () => {
                                img.style.display = 'none';
                                tile.classList.add('empty');
                            };

                            tile.appendChild(img);
                        } else {
                            tile.classList.add('empty');
                        }

                        fragment.appendChild(tile);
                    }
                }
                
                // Append in one shot
                boardElement.appendChild(fragment);
                
                // Delegate clicks to minimise listeners
                if (!this.boardClickHandler) {
                    this.boardClickHandler = (e) => {
                        const tile = e.target.closest('.tile');
                        if (tile && !tile.classList.contains('empty')) {
                            const row = parseInt(tile.dataset.row);
                            const col = parseInt(tile.dataset.col);
                            if (!isNaN(row) && !isNaN(col)) {
                                this.handleTileClick(row, col);
                            }
                        }
                    };
                    boardElement.addEventListener('click', this.boardClickHandler);
                }
            }

            handleTileClick(row, col) {
                if (!this.gameStarted || !this.board[row][col]) return;

                const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

                if (this.selectedTiles.length === 0) {
                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');
                } else if (this.selectedTiles.length === 1) {
                    const first = this.selectedTiles[0];

                    if (first.row === row && first.col === col) {
                        tile.classList.remove('selected');
                        this.selectedTiles = [];
                        return;
                    }

                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');

                    this.moves++;
                    this.updateDisplay();

                    if (this.canConnect(first.row, first.col, row, col)) {
                        this.handleMatch();
                    } else {
                        setTimeout(() => {
                            this.clearSelection();
                        }, 500);
                    }
                }
            }

            canConnect(row1, col1, row2, col2) {
                // Must reference the same image asset
                if (this.board[row1][col1] !== this.board[row2][col2]) {
                    return false;
                }

                // Classic linking rule: up to three straight segments (two bends)
                const result = this.findPath(row1, col1, row2, col2);

                return result;
            }

            findPath(row1, col1, row2, col2) {
                // Zero bends: straight connection
                if (this.canDirectConnect(row1, col1, row2, col2)) {
                    return true;
                }

                // One bend
                if (this.canConnectWithOneCorner(row1, col1, row2, col2)) {
                    return true;
                }

                // Two bends
                if (this.canConnectWithTwoCorners(row1, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // Check if two tiles connect directly (zero bends)
            canDirectConnect(row1, col1, row2, col2) {
                // Same row: horizontal path
                if (row1 === row2) {
                    const start = Math.min(col1, col2);
                    const end = Math.max(col1, col2);

                    // Ensure each intermediate column is empty
                    for (let col = start + 1; col < end; col++) {
                        if (row1 >= 0 && row1 < this.rows && col >= 0 && col < this.cols) {
                            if (this.board[row1][col] !== null) {
                                return false; // blocked
                            }
                        }
                    }
                    return true;
                }

                // Same column: vertical path
                if (col1 === col2) {
                    const start = Math.min(row1, row2);
                    const end = Math.max(row1, row2);

                    // Ensure each intermediate row is empty
                    for (let row = start + 1; row < end; row++) {
                        if (row >= 0 && row < this.rows && col1 >= 0 && col1 < this.cols) {
                            if (this.board[row][col1] !== null) {
                                return false; // blocked
                            }
                        }
                    }
                    return true;
                }

                return false;
            }

            // Attempt a single-bend connection
            canConnectWithOneCorner(row1, col1, row2, col2) {
                if (this.isValidCorner(row1, col2) &&
                    this.canDirectConnect(row1, col1, row1, col2) &&
                    this.canDirectConnect(row1, col2, row2, col2)) {
                    return true;
                }

                if (this.isValidCorner(row2, col1) &&
                    this.canDirectConnect(row1, col1, row2, col1) &&
                    this.canDirectConnect(row2, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // Attempt a two-bend connection (classic U-shapes)
            canConnectWithTwoCorners(row1, col1, row2, col2) {
                if (this.canReachRowBoundary(row1, col1, -1) && this.canReachRowBoundary(row2, col2, -1)) {
                    return true; // escape upwards
                }

                if (this.canReachRowBoundary(row1, col1, this.rows) && this.canReachRowBoundary(row2, col2, this.rows)) {
                    return true; // escape downwards
                }

                if (this.canReachColBoundary(row1, col1, -1) && this.canReachColBoundary(row2, col2, -1)) {
                    return true; // escape left
                }

                if (this.canReachColBoundary(row1, col1, this.cols) && this.canReachColBoundary(row2, col2, this.cols)) {
                    return true; // escape right
                }

                const firstCorners = [];
                for (let row = -1; row <= this.rows; row++) {
                    for (let col = -1; col <= this.cols; col++) {
                        if ((row === row1 && col === col1) || (row === row2 && col === col2)) continue;
                        if (this.canDirectConnect(row1, col1, row, col) && this.isValidCorner(row, col)) {
                            firstCorners.push({row, col});
                        }
                    }
                }

                for (let corner1 of firstCorners) {
                    for (let row = -1; row <= this.rows; row++) {
                        for (let col = -1; col <= this.cols; col++) {
                            if ((row === corner1.row && col === corner1.col) ||
                                (row === row1 && col === col1) ||
                                (row === row2 && col === col2)) continue;

                            if (this.canDirectConnect(corner1.row, corner1.col, row, col) &&
                                this.canDirectConnect(row, col, row2, col2) &&
                                this.isValidCorner(row, col)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            // Corner candidates must be empty or sit outside the board
            isValidCorner(row, col) {
                if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
                    return true;
                }
                return this.board[row][col] === null;
            }

            // Helper for checking a detour via an intermediate point
            canConnectViaPoint(row, col, row1, col1, row2, col2) {
                return this.isValidCorner(row, col) &&
                       this.canDirectConnect(row1, col1, row, col) &&
                       this.canDirectConnect(row, col, row2, col2);
            }

            // Can we travel vertically to the top/bottom boundary?
            canReachRowBoundary(row, col, targetRow) {
                if (targetRow === -1) {
                    for (let r = row - 1; r >= 0; r--) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false;
                        }
                    }
                    return true;
                } else if (targetRow === this.rows) {
                    for (let r = row + 1; r < this.rows; r++) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            // Can we travel horizontally to the left/right boundary?
            canReachColBoundary(row, col, targetCol) {
                if (targetCol === -1) {
                    for (let c = col - 1; c >= 0; c--) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false;
                        }
                    }
                    return true;
                } else if (targetCol === this.cols) {
                    for (let c = col + 1; c < this.cols; c++) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            // Apply match animation and remove the tiles
            handleMatch() {
                const [first, second] = this.selectedTiles;

                first.element.classList.add('matched');
                second.element.classList.add('matched');

                setTimeout(() => {
                    this.board[first.row][first.col] = null;
                    this.board[second.row][second.col] = null;
                    first.element.classList.add('empty');
                    second.element.classList.add('empty');
                    first.element.classList.remove('selected', 'matched');
                    second.element.classList.remove('selected', 'matched');
                }, 500);

                this.score += 100;
                this.updateDisplay();

                this.selectedTiles = [];

                setTimeout(() => {
                    if (this.checkGameEnd()) {
                        this.endGame(true);
                    }
                }, 600);
            }

            // Clear any selected tiles
            clearSelection() {
                this.selectedTiles.forEach(tile => {
                    tile.element.classList.remove('selected');
                });
                this.selectedTiles = [];
            }

            // Provide a hint if any pairs remain
            showHint() {
                if (!this.gameStarted) {
                    alert('Please start the game first!');
                    return;
                }

                if (this.hints <= 0) {
                    alert('No hints left!');
                    return;
                }

                this.clearSelection();

                let found = false;
                for (let r1 = 0; r1 < this.rows; r1++) {
                    for (let c1 = 0; c1 < this.cols; c1++) {
                        if (!this.board[r1][c1]) continue;

                        for (let r2 = 0; r2 < this.rows; r2++) {
                            for (let c2 = 0; c2 < this.cols; c2++) {
                                if (r1 === r2 && c1 === c2) continue;
                                if (!this.board[r2][c2]) continue;

                                if (this.canConnect(r1, c1, r2, c2)) {
                                    const tile1 = document.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
                                    const tile2 = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);

                                    if (tile1 && tile2) {
                                        tile1.style.background = '#f39c12';
                                        tile1.style.border = '3px solid #e67e22';
                                        tile1.style.transform = 'scale(1.1)';
                                        tile1.style.zIndex = '10';

                                        tile2.style.background = '#f39c12';
                                        tile2.style.border = '3px solid #e67e22';
                                        tile2.style.transform = 'scale(1.1)';
                                        tile2.style.zIndex = '10';

                                        let blinkCount = 0;
                                        const blinkInterval = setInterval(() => {
                                            const opacity = blinkCount % 2 === 0 ? '0.7' : '1';
                                            tile1.style.opacity = opacity;
                                            tile2.style.opacity = opacity;
                                            blinkCount++;
                                            if (blinkCount >= 6) {
                                                clearInterval(blinkInterval);
                                            }
                                        }, 200);

                                        setTimeout(() => {
                                            tile1.style.background = '';
                                            tile1.style.border = '';
                                            tile1.style.transform = '';
                                            tile1.style.zIndex = '';
                                            tile1.style.opacity = '';
                                            
                                            tile2.style.background = '';
                                            tile2.style.border = '';
                                            tile2.style.transform = '';
                                            tile2.style.zIndex = '';
                                            tile2.style.opacity = '';
                                        }, 2000);

                                        this.hints--;
                                        this.score = Math.max(0, this.score - 50);
                                        this.updateDisplay();
                                        document.getElementById('hintBtn').textContent = `Hint (${this.hints})`;
                                        found = true;
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                if (!found) {
                    alert('No connectable pairs available right now!');
                }
            }

            // Ensure there are enough connectable pairs before accepting a layout
            hasEnoughConnectablePairs() {
                const pairs = new Map();

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.board[i][j]) {
                            const image = this.board[i][j];
                            if (!pairs.has(image)) {
                                pairs.set(image, []);
                            }
                            pairs.get(image).push({row: i, col: j});
                        }
                    }
                }

                let connectableCount = 0;
                let totalPairs = 0;
                let checkedPairs = 0;
                const maxChecks = 50;

                for (const positions of pairs.values()) {
                    for (let i = 0; i < positions.length; i++) {
                        for (let j = i + 1; j < positions.length; j++) {
                            totalPairs++;

                            if (checkedPairs >= maxChecks) {
                                const ratio = connectableCount / checkedPairs;
                                connectableCount = Math.floor(totalPairs * ratio);
                                break;
                            }

                            const pos1 = positions[i];
                            const pos2 = positions[j];
                            if (this.canConnect(pos1.row, pos1.col, pos2.row, pos2.col)) {
                                connectableCount++;
                            }
                            checkedPairs++;
                        }
                        if (checkedPairs >= maxChecks) break;
                    }
                    if (checkedPairs >= maxChecks) break;
                }

                const minRatio = {
                    easy: 0.6,
                    medium: 0.4,
                    hard: 0.3
                }[this.difficulty] || 0.4;

                const minConnectable = this.difficulty === 'easy' 
                    ? Math.max(4, Math.floor(totalPairs * minRatio))
                    : Math.max(3, Math.floor(totalPairs * minRatio));
                
                return connectableCount >= minConnectable;
            }

            // Determine if the board can be fully cleared
            isSolvable() {
                const boardCopy = this.board.map(row => row.map(cell => cell));
                return this.solveBoard(boardCopy);
            }

            // Backtracking solver with depth guard
            solveBoard(board, depth = 0, maxDepth = 40) {
                const boardSize = board.length * (board[0] ? board[0].length : 0);
                const adaptiveMaxDepth = Math.min(maxDepth, Math.floor(boardSize / 2));
                
                if (depth > adaptiveMaxDepth) {
                    return false;
                }

                let hasTiles = false;
                for (let i = 0; i < board.length && !hasTiles; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] !== null) {
                            hasTiles = true;
                            break;
                        }
                    }
                }
                
                if (!hasTiles) {
                    return true;
                }

                const connectablePairs = [];
                
                for (let r1 = 0; r1 < board.length; r1++) {
                    for (let c1 = 0; c1 < board[r1].length; c1++) {
                        if (board[r1][c1] === null) continue;
                        
                        for (let r2 = 0; r2 < board.length; r2++) {
                            for (let c2 = 0; c2 < board[r2].length; c2++) {
                                if (r1 === r2 && c1 === c2) continue;
                                if (board[r2][c2] === null) continue;
                                if (board[r1][c1] !== board[r2][c2]) continue;
                                
                                if (this.canConnectWithBoard(board, r1, c1, r2, c2)) {
                                    connectablePairs.push({r1, c1, r2, c2});
                                }
                            }
                        }
                    }
                }

                if (connectablePairs.length === 0) {
                    return false;
                }

                const directPairs = [];
                const otherPairs = [];
                
                for (const pair of connectablePairs) {
                    if (this.canDirectConnectWithBoard(board, pair.r1, pair.c1, pair.r2, pair.c2)) {
                        directPairs.push(pair);
                    } else {
                        otherPairs.push(pair);
                    }
                }
                
                const sortedPairs = [...directPairs, ...otherPairs];
                
                for (const pair of sortedPairs) {
                    const newBoard = board.map(row => row.map(cell => cell));
                    
                    newBoard[pair.r1][pair.c1] = null;
                    newBoard[pair.r2][pair.c2] = null;
                    
                    if (this.solveBoard(newBoard, depth + 1, maxDepth)) {
                        return true;
                    }
                }

                return false;
            }

            // Direct-connection helper for solver
            canDirectConnectWithBoard(board, row1, col1, row2, col2) {
                if (row1 === row2) {
                    const start = Math.min(col1, col2);
                    const end = Math.max(col1, col2);

                    for (let col = start + 1; col < end; col++) {
                        if (row1 >= 0 && row1 < board.length && col >= 0 && col < board[row1].length) {
                            if (board[row1][col] !== null) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                if (col1 === col2) {
                    const start = Math.min(row1, row2);
                    const end = Math.max(row1, row2);

                    for (let row = start + 1; row < end; row++) {
                        if (row >= 0 && row < board.length && col1 >= 0 && col1 < board[row].length) {
                            if (board[row][col1] !== null) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                return false;
            }

            // Can two tiles connect using the provided board state?
            canConnectWithBoard(board, row1, col1, row2, col2) {
                if (board[row1][col1] !== board[row2][col2]) {
                    return false;
                }

                const tempBoard = this.board;
                this.board = board;
                const result = this.findPath(row1, col1, row2, col2);
                this.board = tempBoard;
                
                return result;
            }

            startTimer() {
                this.timer = setInterval(() => {
                    this.timeElapsed++;
                    this.updateTimer();
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }

            updateTimer() {
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = this.timeElapsed % 60;
                document.getElementById('time').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                this.updateTimer();
            }

            restartGame() {
                this.stopTimer();
                this.gameStarted = false;
                this.selectedTiles = [];
                
                const boardElement = document.getElementById('gameBoard');
                if (this.boardClickHandler) {
                    boardElement.removeEventListener('click', this.boardClickHandler);
                    this.boardClickHandler = null;
                }
                boardElement.innerHTML = '';
                
                this.startGame();
            }

            endGame(won) {
                this.stopTimer();
                this.gameStarted = false;
                
                const overlay = document.getElementById('overlay');
                const gameOver = document.getElementById('gameOver');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');
                
                if (won) {
                    title.textContent = 'üéâ Victory!';
                    message.innerHTML = `
                        Time: ${document.getElementById('time').textContent}<br>
                        Score: ${this.score}<br>
                        Moves: ${this.moves}<br>
                        Difficulty: ${this.getDifficultyText()}
                    `;
                } else {
                    title.textContent = 'Game Over';
                    message.textContent = `Final score: ${this.score}`;
                }
                
                overlay.style.display = 'block';
                gameOver.style.display = 'block';
            }

            getDifficultyText() {
                const texts = {
                    easy: 'Easy',
                    medium: 'Medium',
                    hard: 'Hard'
                };
                return texts[this.difficulty] || this.difficulty;
            }
        }

        // Initialize the game
        let game;
        try {
            game = new LinkUpPuzzle();
        } catch (error) {
            alert('Failed to initialise game: ' + error.message);
        }

        // Global helper
        function restartGame() {
            if (!game) return;
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            game.restartGame();
        }
    </script>
</body>
</html>
</html>